/**
 * Forecast API Initializer - Kh·ªüi t·∫°o sample data cho h·ªá th·ªëng d·ª± b√°o
 */

const forecastService = require('../services/forecastService');

/**
 * Kh·ªüi t·∫°o sample stations cho h·ªá th·ªëng
 */
async function initializeForecastStations() {
    console.log('üîÑ Initializing forecast stations...');

    const sampleStations = [
        {
            stationId: 'HDT_001',
            stationUuid: '613bbcf5-212e-43c5-9ef8-69016787454f',
            stationName: 'H·ªì D·∫ßu Ti·∫øng',
            location: {
                latitude: 11.2838,
                longitude: 106.3619
            },
            administrativeInfo: {
                province: 'T√¢y Ninh',
                district: 'D·∫ßu Ti·∫øng',
                riverSystem: 'S√†i G√≤n'
            },
            supportedParameters: [
                {
                    parameterCode: 'MUCNUOCHO',
                    parameterName: 'M·ª±c n∆∞·ªõc h·ªì',
                    unit: 'm',
                    minValue: 0,
                    maxValue: 50,
                    decimalPlaces: 2
                },
                {
                    parameterCode: 'QDEN',
                    parameterName: 'D√≤ng ch·∫£y ƒë·∫øn h·ªì',
                    unit: 'm¬≥/s',
                    minValue: 0,
                    maxValue: 1000,
                    decimalPlaces: 2
                }
            ],
            apiConfig: {
                fetchInterval: 3600, // 1 hour
                forecastDays: 3,
                realtimeLookback: 24,
                autoSync: true
            },
            metadata: {
                description: 'Tr·∫°m ch√≠nh thu th·∫≠p d·ªØ li·ªáu t·ª´ API H·ªì D·∫ßu Ti·∫øng',
                contact: 'Hydrology Team',
                dataOwner: 'H·ªì D·∫ßu Ti·∫øng Management'
            }
        },
        // C√≥ th·ªÉ th√™m c√°c tr·∫°m kh√°c trong t∆∞∆°ng lai
        {
            stationId: 'VT_TIDE',
            stationUuid: 'vung-tau-tide-001',
            stationName: 'V≈©ng T√†u Tide Station',
            location: {
                latitude: 10.3460,
                longitude: 107.0843
            },
            administrativeInfo: {
                province: 'B√† R·ªãa - V≈©ng T√†u',
                district: 'V≈©ng T√†u',
                riverSystem: 'S√†i G√≤n'
            },
            supportedParameters: [
                {
                    parameterCode: 'MUCNUOCHO',
                    parameterName: 'M·ª±c n∆∞·ªõc th·ªßy tri·ªÅu',
                    unit: 'm',
                    minValue: -2,
                    maxValue: 5,
                    decimalPlaces: 3
                }
            ],
            apiConfig: {
                fetchInterval: 1800, // 30 minutes
                forecastDays: 7,
                realtimeLookback: 48,
                autoSync: true
            },
            status: 'inactive', // Ch∆∞a c√≥ API integration
            metadata: {
                description: 'Tr·∫°m th·ªßy tri·ªÅu V≈©ng T√†u (d·ª± ph√≤ng cho t∆∞∆°ng lai)',
                contact: 'Hydrology Team'
            }
        }
    ];

    let successCount = 0;
    let errorCount = 0;

    for (const stationData of sampleStations) {
        try {
            const result = await forecastService.registerStation(stationData);
            
            if (result.success) {
                console.log(`‚úÖ Station initialized: ${stationData.stationName}`);
                successCount++;
            } else {
                // Station might already exist
                console.log(`‚ÑπÔ∏è Station exists: ${stationData.stationName}`);
                successCount++;
            }
            
        } catch (error) {
            console.error(`‚ùå Error initializing station ${stationData.stationName}: ${error.message}`);
            errorCount++;
        }
    }

    console.log(`‚úÖ Forecast stations initialization completed: ${successCount} success, ${errorCount} errors`);
    return { successCount, errorCount, total: sampleStations.length };
}

/**
 * Ch·∫°y initial sync ƒë·ªÉ test h·ªá th·ªëng
 */
async function runInitialSync() {
    console.log('üîÑ Running initial forecast data sync...');

    try {
        const result = await forecastService.syncAllStations();
        
        if (result.success) {
            const { data } = result;
            console.log(`‚úÖ Initial sync completed:`);
            console.log(`   - Stations processed: ${data.totalStations}`);
            console.log(`   - Successful syncs: ${data.successfulSyncs}`);
            console.log(`   - Failed syncs: ${data.failedSyncs}`);
            console.log(`   - Total records: ${data.totalRecords}`);
            
            if (data.errors.length > 0) {
                console.log(`‚ö†Ô∏è Sync warnings: ${data.errors.length} issues found`);
            }
            
            return { success: true, data };
        } else {
            console.error(`‚ùå Initial sync failed: ${result.error}`);
            return { success: false, error: result.error };
        }
        
    } catch (error) {
        console.error(`‚ùå Initial sync error: ${error.message}`);
        return { success: false, error: error.message };
    }
}

/**
 * Ki·ªÉm tra health c·ªßa h·ªá th·ªëng forecast
 */
async function checkForecastHealth() {
    try {
        // Ki·ªÉm tra s·ªë stations active
        const stationsResult = await forecastService.getStations({ status: 'active' });
        const activeStations = stationsResult.success ? stationsResult.data.length : 0;
        
        // Ki·ªÉm tra d·ªØ li·ªáu m·ªõi nh·∫•t
        let hasRecentData = false;
        if (activeStations > 0) {
            const latestDataResult = await forecastService.getLatestData(
                '613bbcf5-212e-43c5-9ef8-69016787454f',
                'MUCNUOCHO'
            );
            hasRecentData = latestDataResult.success && latestDataResult.data;
        }
        
        const health = {
            status: activeStations > 0 ? 'healthy' : 'warning',
            activeStations,
            hasRecentData,
            timestamp: new Date().toISOString()
        };
        
        console.log(`üíö Forecast system health: ${health.status}`);
        console.log(`   - Active stations: ${activeStations}`);
        console.log(`   - Recent data available: ${hasRecentData}`);
        
        return health;
        
    } catch (error) {
        console.error(`‚ùå Health check failed: ${error.message}`);
        return {
            status: 'error',
            error: error.message,
            timestamp: new Date().toISOString()
        };
    }
}

/**
 * Complete initialization process
 */
async function initializeForecastSystem() {
    console.log('\nüöÄ ===== FORECAST SYSTEM INITIALIZATION ===== üöÄ');
    
    try {
        // Step 1: Initialize stations
        const stationResult = await initializeForecastStations();
        
        // Step 2: Wait a moment for DB operations
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Step 3: Run initial sync (optional - c√≥ th·ªÉ skip n·∫øu kh√¥ng mu·ªën g·ªçi API ngay)
        const shouldRunInitialSync = process.env.FORECAST_INITIAL_SYNC !== 'false';
        let syncResult = null;
        
        if (shouldRunInitialSync) {
            syncResult = await runInitialSync();
        } else {
            console.log('‚ÑπÔ∏è Skipping initial sync (FORECAST_INITIAL_SYNC=false)');
        }
        
        // Step 4: Health check
        const healthResult = await checkForecastHealth();
        
        console.log('\n‚úÖ ===== FORECAST SYSTEM READY ===== ‚úÖ');
        
        return {
            success: true,
            stations: stationResult,
            sync: syncResult,
            health: healthResult
        };
        
    } catch (error) {
        console.error('\n‚ùå ===== FORECAST SYSTEM INITIALIZATION FAILED ===== ‚ùå');
        console.error(error);
        
        return {
            success: false,
            error: error.message
        };
    }
}

module.exports = {
    initializeForecastStations,
    runInitialSync,
    checkForecastHealth,
    initializeForecastSystem
};